<!DOCTYPE html>
<!--
  Derived from go2rtc stream.html
  https://github.com/AlexxIT/go2rtc/blob/master/www/stream.html
  Copyright (c) 2022 Alexey Khit — MIT License
  https://github.com/AlexxIT/go2rtc/blob/master/LICENSE
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Camera</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; width: 100%; }
        body {
            background: #111;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #container {
            position: relative;
            width: 100%;
            max-width: 1280px;
            aspect-ratio: 16/9;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        video-stream {
            display: block;
            width: 100%;
            height: 100%;
        }
        #overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #000;
            z-index: 10;
            transition: opacity 0.4s ease;
        }
        #overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #overlay svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.6;
        }
        #overlay .message {
            font-size: 1.25rem;
            opacity: 0.9;
            text-align: center;
            padding: 0 1rem;
        }
        #overlay .submessage {
            font-size: 0.85rem;
            opacity: 0.5;
            margin-top: 8px;
        }
        #spinner {
            display: none;
            width: 32px;
            height: 32px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 16px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Status bar — below-video layout (default: landscape wider than 16:9) */
        #status-bar {
            display: none;
            width: 100%;
            max-width: 1280px;
            margin-top: 8px;
            padding: 6px 14px;
            background: #1a1a1a;
            border-radius: 6px;
            font-size: 1.5rem;
            color: rgba(255,255,255,0.65);
            gap: 16px;
            flex-wrap: wrap;
        }

        /* Overlay layout — portrait/square screens where video fills the viewport */
        @media (max-aspect-ratio: 16/9) {
            body { flex-direction: column; align-items: center; justify-content: center; }
            #status-bar {
                position: absolute;
                bottom: 0;
                left: 0; right: 0;
                max-width: none;
                margin-top: 0;
                border-radius: 0;
                background: rgba(0,0,0,0.6);
                backdrop-filter: blur(4px);
                -webkit-backdrop-filter: blur(4px);
                z-index: 5;
            }
        }

        #status-bar.visible { display: flex; }
        #status-bar span { white-space: nowrap; }
    </style>
</head>
<body>
    <div id="container">
        <div id="overlay">
            <div id="spinner"></div>
            <svg id="cam-off-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                 stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M16.7 19.3L2 4.6"/>
                <path d="M2 4.6l1.4-1.4"/>
                <path d="M9.5 4H18a2 2 0 012 2v3.5l4-3v9l-1.7-1.3"/>
                <path d="M20 16.2V18a2 2 0 01-2 2H5.8"/>
                <path d="M2 8v10a2 2 0 002 2h1"/>
            </svg>
            <div class="message" id="message">Connecting…</div>
            <div class="submessage" id="submessage"></div>
        </div>
    </div>
    <div id="status-bar"></div>

<!-- Intercept WebSocket BEFORE any modules load -->
<script>
    (function() {
        var src = new URLSearchParams(location.search).get('src');

        // Redirect to a safe error if no src param provided
        if (!src) {
            document.getElementById('message').textContent = 'No stream specified.';
            document.getElementById('spinner').style.display = 'none';
            document.getElementById('cam-off-icon').style.display = 'block';
            return;
        }

        // Set page title from stream name
        document.title = src.replace(/_/g, ' ');

        var overlay = document.getElementById('overlay');
        var message = document.getElementById('message');
        var submessage = document.getElementById('submessage');
        var spinner = document.getElementById('spinner');
        var camIcon = document.getElementById('cam-off-icon');

        // Initial state: connecting
        spinner.style.display = 'block';
        camIcon.style.display = 'none';

        window.__streamSrc = src;
        window.__streamState = { connected: false, unavailable: false };

        function showUnavailable() {
            spinner.style.display = 'none';
            camIcon.style.display = 'block';
            message.textContent = 'Stream not available at this time.';
            submessage.textContent = 'The camera stream is currently offline.';
            overlay.classList.remove('hidden');
            window.__streamState.unavailable = true;
        }

        function showConnecting() {
            spinner.style.display = 'block';
            camIcon.style.display = 'none';
            message.textContent = 'Connecting…';
            submessage.textContent = '';
            overlay.classList.remove('hidden');
            window.__streamState.unavailable = false;
        }

        window.__streamHideOverlay = function() {
            overlay.classList.add('hidden');
            window.__streamState.connected = true;
            window.__streamState.unavailable = false;
        };

        // Shim WebSocket to detect errors immediately.
        // go2rtc accepts the WS connection even when stream doesn't exist,
        // then sends {"type":"error","value":"..."} as a message.
        var OrigWS = window.WebSocket;
        window.WebSocket = function(url, protocols) {
            var ws = protocols ? new OrigWS(url, protocols) : new OrigWS(url);
            var gotError = false;
            ws.addEventListener('message', function(ev) {
                if (typeof ev.data === 'string') {
                    try {
                        var msg = JSON.parse(ev.data);
                        if (msg.type === 'error') {
                            gotError = true;
                            showUnavailable();
                        }
                    } catch(e) {}
                } else if (ev.data instanceof ArrayBuffer || ev.data instanceof Blob) {
                    // Binary data = stream is delivering video
                    if (!gotError && window.__streamState.unavailable) {
                        showConnecting();
                    }
                }
            });
            ws.addEventListener('close', function() {
                if (window.__streamState.connected) {
                    // Was connected, now lost — stream was disabled
                    window.__streamState.connected = false;
                    showUnavailable();
                }
            });
            return ws;
        };
        window.WebSocket.prototype = OrigWS.prototype;
        window.WebSocket.CONNECTING = OrigWS.CONNECTING;
        window.WebSocket.OPEN = OrigWS.OPEN;
        window.WebSocket.CLOSING = OrigWS.CLOSING;
        window.WebSocket.CLOSED = OrigWS.CLOSED;

        // Poll: when unavailable, probe for stream availability every 30s.
        // When stream doesn't exist, go2rtc sends an error message immediately.
        // When stream exists, go2rtc sends nothing (waits for mode request).
        // So: if no error within 2s of open, stream is back — reload to reconnect.
        setInterval(function() {
            if (!window.__streamState.unavailable) return;
            var wsProto = location.protocol === 'https:' ? 'wss:' : 'ws:';
            var probeUrl = wsProto + '//' + location.host + '/api/ws?src=' + encodeURIComponent(src);
            var probe = new OrigWS(probeUrl);
            var done = false;
            var gotError = false;

            probe.addEventListener('message', function(ev) {
                if (done) return;
                if (typeof ev.data === 'string') {
                    try {
                        var msg = JSON.parse(ev.data);
                        if (msg.type === 'error') {
                            gotError = true;
                            done = true;
                            probe.close();
                        }
                    } catch(e) {}
                }
            });

            probe.addEventListener('open', function() {
                // Wait 2s — if no error arrived, stream exists
                setTimeout(function() {
                    if (done) return;
                    done = true;
                    probe.close();
                    if (!gotError) {
                        location.reload();
                    }
                }, 2000);
            });

            // Failsafe: close after 5s
            setTimeout(function() {
                if (!done) {
                    done = true;
                    probe.close();
                }
            }, 5000);
        }, 30000);
    })();
</script>

<!-- Status bar: fetch snapshot + subscribe to SSE updates -->
<script>
(function() {
    var src = new URLSearchParams(location.search).get('src');
    if (!src) return;

    var bar = document.getElementById('status-bar');

    function renderStatus(data) {
        if (!data || data.available === false) {
            bar.classList.remove('visible');
            return;
        }
        var parts = [];
        if (data.status != null)  parts.push('<span>' + data.status + '</span>');
        if (data.viewers != null) parts.push('<span>\u00B7 ' + data.viewers +
                                    ' viewer' + (data.viewers !== 1 ? 's' : '') + '</span>');
        if (parts.length) {
            bar.innerHTML = parts.join('');
            bar.classList.add('visible');
        }
    }

    // Initial snapshot
    fetch('/status/' + encodeURIComponent(src))
        .then(function(r) { return r.ok ? r.json() : null; })
        .then(renderStatus)
        .catch(function() {});

    // SSE stream — live updates
    var evtSource = new EventSource('/status/' + encodeURIComponent(src) + '/events');
    var errs = 0;
    evtSource.onerror = function() { if (++errs > 3) evtSource.close(); };
    evtSource.onmessage = function(e) {
        errs = 0;
        try { renderStatus(JSON.parse(e.data)); } catch(err) {}
    };
})();
</script>

<script type="module" src="/video-stream.js"></script>
<script type="module">
    var src = new URLSearchParams(location.search).get('src');
    if (src) {
        const container = document.getElementById('container');
        const video = document.createElement('video-stream');
        video.background = true;
        video.mode = 'mse';
        video.style.width = '100%';
        video.style.height = '100%';
        video.src = new URL('/api/ws?src=' + encodeURIComponent(src), location.href);
        container.insertBefore(video, document.getElementById('overlay'));

        // Monitor the inner video element for playback
        const checkInterval = setInterval(() => {
            const inner = video.querySelector('video');
            if (!inner) return;
            inner.addEventListener('playing', () => window.__streamHideOverlay());
            clearInterval(checkInterval);
        }, 200);
    }
</script>
</body>
</html>
